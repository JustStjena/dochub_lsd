entities:
  contexts:
    menu: >
      (
        $presentation := entities.contexts.config.defaultPresentation;
        $append([
            {
                "title": "Контексты",
                "location": '04. Прикладная архитектура/03. Верхнеуровневый прикладной ландшафт (ПА-L1)',
                "icon": 'location_searching'
            }
          ],
          contexts.$spread().(
              /* Если указана явно презентация, используем ее */
              $presentation := $.*.presentation ? *.presentation : $presentation;
              *.location ? {
                  "location": "04. Прикладная архитектура/03. Верхнеуровневый прикладной ландшафт (ПА-L1)/" & *.location,
                  "link": "entities/contexts/" & $presentation & "?dh-context-id=" & $keys()[0]
              }
          )
        );
      )
    config:
      defaultPresentation: c4_context
      renderCore: elk
    api:
      c4_context:
        mapping:
          system: System
          database: SystemDb
          person: Person
          actor: Person
      # Возввращает компоненты входящие в контекст
      # Входящие параметры:
      #   manifest      - данные архитектуры
      #   contextId     - идентификатор контекста
      #   extra-links   - признак необходимости отразить окружение
      #   componentId   - идентификатор компонента для контекста SELF
      fetchComponents: >
        (
          /* Обрабатываем параметры */
          $params := $;
          $manifest := $params.manifest;
          $context := $lookup($params.manifest.contexts, contextId);

          /* Определяем необходимость показывать ближайшие связи */
          $isExtraLinks := $params.componentId ? true : $params."extra-links";

          /* Определяем, какие компоненты покажем в контексте */
          $showComponents := $params.componentId
            /* Если контекст под определенный компонент, ограничиваемся им. */
            ? [$params.componentId]
            /* Если нет берем все компоненты указанные в контексте */
            : $context.components; 
  
          /* Если в контексте переопределена функция получения компонентов, используем ее*/
          $context.api.fetchComponents ? (
            $eval($context.api.fetchComponents, $params)
          ) : (
            /* Получаем все компоненты входящие в контекст */
            $components := $merge($showComponents.(
                $mask := $;
                $manifest.components.$spread().(
                    $componentId := $keys()[0];
                    $wcard($componentId, $mask) ? $
                )
            ));
          
            /* Добавляем окружение, если это нужно */
            $merge([$components, $isExtraLinks ? (
                $components.*.links.(
                    {
                        id: $lookup($manifest.components, id)
                    }
                );
            ) : {}]);
          )
        )
      # На основании списка компонентов генерирует массиа областей которые они затрагивают
      # Входящие параметры:
      #   components - список компонентов в формате fetchComponents
      fetchAreas: >
        (
          $distinct(components.$spread().(
              $componentId := $keys()[0];
              $domains := $componentId.$split(".");
              $limit := $count($domains) - 1;
              $areaId := $map($domains, function($v, $i) {(
                  $join($map($domains, function($sv, $si) {
                      $si <= $i ? $sv
                  }), ".")
              )});
          ))^($);
        )
      # Генерирует список отображаемых связей
      # Входящие параметры:
      #   components - список компонентов в формате fetchComponents
      fetchLinks: >
        (
          /* Обрабатываем параметры */
          $components := components;
          $distinct(
              $components.$spread().(
                  $from := $keys()[0];
                  $direction := $.*.direction ? $.*.direction : "--";
                  $.*.links[$lookup($components, id)].(
                    $title := title ? title : contract;
                    $title := contract ? ("[[/docs/" & contract & " " & $title & "]]") : $title;
                    {
                      "from": $from,
                      "to": (id ? id : "undefined"),
                      "title": $title,
                      "contract": contract,
                      "direction": direction ? direction : "--"
                    }
                  )
              )
          );
        )
        
      fetchTitle: >
        (
          context.title ? context.title : componentId
          )
          
    presentations:
      c4_context:
        title: Представление в C4 Context PlantUML
        params:
          title: Требуемые параметры для презентации
          type: object
          properties:
            "dh-context-id":
              title: Идентификатор контекста
              type: string
              pattern: ^[a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$
          required:
            - dh-context-id
        type: plantuml
        template: templates/context.puml
        $constructor: >  # Переносим необходимую информацию из контекста в презентацию 
          (
            $id := $params."dh-context-id";
            $context := $lookup(contexts, $id);
            $prototype := entities.contexts.presentations.c4_context;
          
            /* Преобразует относительные пути к файлам в прямые*/
            $toDirectRes := function($value) {
                $substring($value, 0, 4) = "res:" ? $value : "res://contexts/" & $id & "#" & $value
            };

            /* Если явно указан puml файл, просто рендерим его */
            $substring($context.uml, -5) = ".puml" ? (
                {
                  "type": "plantuml",
                  "source": $toDirectRes($context.uml)
                }
            ) : (
                $result := $context.source ? ($merge([$prototype, {
                    "origin": { "_source": $context.source, "_origin": "($)" }
                }])) : $prototype;

                /* Если в контексте переопределен шаблон, используем его по прямой ссылке */
                $result := $context.template 
                    ? $merge([$result, { "template":  $toDirectRes($context.template) }])
                    : $result;
            )
          )
        source: >
          (
            $id := $params."dh-context-id";
            /* Получаем доступ к оригинальным данным */
            $manifest := _origin ? _origin : $;
            /* Получаем контекст */
            $context := $lookup($manifest.contexts, $id);
            /* Если в контексте задан источник, берем его за основу */
            $manifest := _source ? _source : $;
          
            $isExtraLinks := $not($string($context."extra-links") = "false");
          
            /* Получаем коллекцию дефолтных вспомогательных функций */
            $defFunctions := $manifest.entities.contexts.api;
          
            /* Получаем коллекцию дефолтных параметров */
            $defConfig := $manifest.entities.contexts.config; 
          
            /* Определяем движок рендеринга */
            $renderCore := $lookup({
              "elk": "!pragma layout elk",
              "smetana": "!pragma layout smetana"
            }, $defConfig.renderCore);

            $fetchTitle := $exists($context.api) and $exists($context.api.fetchTitle) ?
              $context.api.fetchTitle : $defFunctions.fetchTitle;
            $title := $eval($fetchTitle, {
              "manifest": $manifest,
              "context": $context,
              "contextId": $id,
              "componentId": $params.componentId
            });
            /* Формируем заголовок */
            $header := "title: " & $title & "\n";
          
            $tags := $exists($context.api) and $exists($context.api.tags) ? (
              $join(
                $context.api.tags.$spread().{
                    "id": $keys()[0],
                    "value": $.*}.(
                    "AddElementTag(" & id & "," &
                    $join(value.$spread().{
                        "key": $keys()[0],
                        "value": $.*
                    }.(
                        key & "=" & value
                    ), ",") & ")\n"
                )
              , "\n")
            ) : ("");

            /* Получаем все компоненты входящие в контекст */
            $components := $eval($defFunctions.fetchComponents, {
              "manifest": $manifest,
              "contextId": $id,
              "extra-links": $isExtraLinks,
              "componentId": $params.componentId
            });

            /* Генерируем области */
            $areas := $eval($defFunctions.fetchAreas, {
              "components": $components
            });
          
            /* Генерируем PlantUML диаграмму компонентов */
            $elements := (
                        $join($map($areas, function($domain, $index) {(
                            $result := "";
                            $component := $lookup($components, $domain);
                            $component := $not($exists($component)) ? ($lookup($manifest.components, $domain)) : $component;
                            $context := $lookup($manifest.contexts, $domain);

                            /* Определяем является ли элемент областью */
                            $isAreaBegin := $areas[$index + 1].$substring(0, $domain.$length() + 1) = $domain & ".";

                            $result := $result & ($isAreaBegin ? (
                                $title := $component.title ? $component.title : (
                                    $context.title ? $context.title : $domain
                                );
                                    "Boundary"
                                    & ($component.external ? "_Ext" : "")
                                    & "("
                                    & $domain & ","
                                    & $title
                                    & ") {\n";
                            ) : "");

                            /* Если домен является компонентом, выводим его на диаграмму */
                            $result := $result & (
                                $not($isAreaBegin) and $component ? (
                                    /* Открываем секцию компонента */
                                    $entity := $lookup($defFunctions.c4_context.mapping, $component.entity ? $component.entity : "system");
                                    $entity := $not($exists($entity))? "System": $entity;
                                    $entity
                                    & ($component.external ? "_Ext" : "") 
                                    & "("
                                    & $domain
                                    & ","
                                    & $component.title
                                    & ","
                                    & "$link=" & "/architect/components/" & $domain
                                    & ($exists($component.tags) ? (
                                      ", $tags=" & $join($component.tags, ",")
                                    ))
                                    & ")\n";
                                ): "";
                            );

                            /* Определяем, что область нужно закрыть*/
                            $result & (
                              $count($split($domain, ".")) > 1 
                              and ($count($split($domain, ".")) > $count($split($areas[$index + 1], "."))
                            ) ? "}\n" : "");
                        )}));
                      );
            /* Получаем список связей */
            $links := $eval($defFunctions.fetchLinks, {
              "components": $components
            });
          
            /* Генерируем код связей */
            $linksCode := $join($links.(
              "Rel("
              &from
              &"," 
              &to
              &",\""
              &title
              &"\", "
              &"$link=\""
              &link
              &"\")\n"
            ), "");
          
            /* Готовим данные для передачи в шаблон */
            {
              "renderCore": $renderCore,
              "presentation": $defConfig.defaultPresentation,
              "code": $header & $tags & $elements & $linksCode
            }
          )
